!function(t){var o={};function r(n){if(o[n])return o[n].exports;var e=o[n]={i:n,l:!1,exports:{}};return t[n].call(e.exports,e,e.exports,r),e.l=!0,e.exports}r.m=t,r.c=o,r.d=function(n,e,t){r.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},r.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},r.t=function(e,n){if(1&n&&(e=r(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(r.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)r.d(t,o,function(n){return e[n]}.bind(null,o));return t},r.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return r.d(e,"a",e),e},r.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},r.p="",r(r.s="./js/vendor.js")}({"./js/vendor.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _vendor_jump__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vendor/jump */ \"./js/vendor/jump.js\");\n/* harmony import */ var _vendor_jump__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_vendor_jump__WEBPACK_IMPORTED_MODULE_0__);\n// import './vendor/swiper';\n\n\n//# sourceURL=webpack:///./js/vendor.js?")},"./js/vendor/jump.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof2(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\n(function (global, factory) {\n  ( false ? undefined : _typeof2(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\n})(this, function () {\n  'use strict'; // Robert Penner's easeInOutQuad\n  // find the rest of his easing functions here: http://robertpenner.com/easing/\n  // find them exported for ES6 consumption here: https://github.com/jaxgeller/ez.js\n\n  var easeInOutQuad = function easeInOutQuad(t, b, c, d) {\n    t /= d / 2;\n    if (t < 1) return c / 2 * t * t + b;\n    t--;\n    return -c / 2 * (t * (t - 2) - 1) + b;\n  };\n\n  var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n    return _typeof2(obj);\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n  };\n\n  var jumper = function jumper() {\n    // private variable cache\n    // no variables are created during a jump, preventing memory leaks\n    var element = void 0; // element to scroll to                   (node)\n\n    var start = void 0; // where scroll starts                    (px)\n\n    var stop = void 0; // where scroll stops                     (px)\n\n    var offset = void 0; // adjustment from the stop position      (px)\n\n    var easing = void 0; // easing function                        (function)\n\n    var a11y = void 0; // accessibility support flag             (boolean)\n\n    var distance = void 0; // distance of scroll                     (px)\n\n    var duration = void 0; // scroll duration                        (ms)\n\n    var timeStart = void 0; // time scroll started                    (ms)\n\n    var timeElapsed = void 0; // time spent scrolling thus far          (ms)\n\n    var next = void 0; // next scroll position                   (px)\n\n    var callback = void 0; // to call when done scrolling            (function)\n    // scroll position helper\n\n    function location() {\n      return window.scrollY || window.pageYOffset;\n    } // element offset helper\n\n\n    function top(element) {\n      return element.getBoundingClientRect().top + start;\n    } // rAF loop helper\n\n\n    function loop(timeCurrent) {\n      // store time scroll started, if not started already\n      if (!timeStart) {\n        timeStart = timeCurrent;\n      } // determine time spent scrolling so far\n\n\n      timeElapsed = timeCurrent - timeStart; // calculate next scroll position\n\n      next = easing(timeElapsed, start, distance, duration); // scroll to it\n\n      window.scrollTo(0, next); // check progress\n\n      timeElapsed < duration ? window.requestAnimationFrame(loop) // continue scroll loop\n      : done(); // scrolling is done\n    } // scroll finished helper\n\n\n    function done() {\n      // account for rAF time rounding inaccuracies\n      window.scrollTo(0, start + distance); // if scrolling to an element, and accessibility is enabled\n\n      if (element && a11y) {\n        // add tabindex indicating programmatic focus\n        element.setAttribute('tabindex', '-1'); // focus the element\n\n        element.focus();\n      } // if it exists, fire the callback\n\n\n      if (typeof callback === 'function') {\n        callback();\n      } // reset time for next jump\n\n\n      timeStart = false;\n    } // API\n\n\n    function jump(target) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // resolve options, or use defaults\n\n      duration = options.duration || 1000;\n      offset = options.offset || 0;\n      callback = options.callback; // \"undefined\" is a suitable default, and won't be called\n\n      easing = options.easing || easeInOutQuad;\n      a11y = options.a11y || false; // cache starting position\n\n      start = location(); // resolve target\n\n      switch (typeof target === 'undefined' ? 'undefined' : _typeof(target)) {\n        // scroll from current position\n        case 'number':\n          element = undefined; // no element to scroll to\n\n          a11y = false; // make sure accessibility is off\n\n          stop = start + target;\n          break;\n        // scroll to element (node)\n        // bounding rect is relative to the viewport\n\n        case 'object':\n          element = target;\n          stop = top(element);\n          break;\n        // scroll to element (selector)\n        // bounding rect is relative to the viewport\n\n        case 'string':\n          element = document.querySelector(target);\n          stop = top(element);\n          break;\n      } // resolve scroll distance, accounting for offset\n\n\n      distance = stop - start + offset; // resolve duration\n\n      switch (_typeof(options.duration)) {\n        // number in ms\n        case 'number':\n          duration = options.duration;\n          break;\n        // function passed the distance of the scroll\n\n        case 'function':\n          duration = options.duration(distance);\n          break;\n      } // start the loop\n\n\n      window.requestAnimationFrame(loop);\n    } // expose only the jump method\n\n\n    return jump;\n  }; // export singleton\n\n\n  var singleton = jumper();\n  return singleton;\n});\n\n//# sourceURL=webpack:///./js/vendor/jump.js?")}});